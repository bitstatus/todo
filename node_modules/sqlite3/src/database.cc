#include <string.h>
<<<<<<< HEAD
=======
#include <node.h>
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

#include "macros.h"
#include "database.h"
#include "statement.h"

using namespace node_sqlite3;

<<<<<<< HEAD
Nan::Persistent<FunctionTemplate> Database::constructor_template;

NAN_MODULE_INIT(Database::Init) {
    Nan::HandleScope scope;

    Local<FunctionTemplate> t = Nan::New<FunctionTemplate>(New);

    t->InstanceTemplate()->SetInternalFieldCount(1);
    t->SetClassName(Nan::New("Database").ToLocalChecked());

    Nan::SetPrototypeMethod(t, "close", Close);
    Nan::SetPrototypeMethod(t, "exec", Exec);
    Nan::SetPrototypeMethod(t, "wait", Wait);
    Nan::SetPrototypeMethod(t, "loadExtension", LoadExtension);
    Nan::SetPrototypeMethod(t, "serialize", Serialize);
    Nan::SetPrototypeMethod(t, "parallelize", Parallelize);
    Nan::SetPrototypeMethod(t, "configure", Configure);

    NODE_SET_GETTER(t, "open", OpenGetter);

    constructor_template.Reset(t);

    Nan::Set(target, Nan::New("Database").ToLocalChecked(),
        Nan::GetFunction(t).ToLocalChecked());
}

void Database::Process() {
    Nan::HandleScope scope;

    if (!open && locked && !queue.empty()) {
        EXCEPTION(Nan::New("Database handle is closed").ToLocalChecked(), SQLITE_MISUSE, exception);
=======
Persistent<FunctionTemplate> Database::constructor_template;

void Database::Init(Handle<Object> target) {
    NanScope();

    Local<FunctionTemplate> t = NanNew<FunctionTemplate>(New);

    t->InstanceTemplate()->SetInternalFieldCount(1);
    t->SetClassName(NanNew("Database"));

    NODE_SET_PROTOTYPE_METHOD(t, "close", Close);
    NODE_SET_PROTOTYPE_METHOD(t, "exec", Exec);
    NODE_SET_PROTOTYPE_METHOD(t, "wait", Wait);
    NODE_SET_PROTOTYPE_METHOD(t, "loadExtension", LoadExtension);
    NODE_SET_PROTOTYPE_METHOD(t, "serialize", Serialize);
    NODE_SET_PROTOTYPE_METHOD(t, "parallelize", Parallelize);
    NODE_SET_PROTOTYPE_METHOD(t, "configure", Configure);

    NODE_SET_GETTER(t, "open", OpenGetter);

    NanAssignPersistent(constructor_template, t);

    target->Set(NanNew("Database"),
        t->GetFunction());
}

void Database::Process() {
    NanScope();

    if (!open && locked && !queue.empty()) {
        EXCEPTION(NanNew<String>("Database handle is closed"), SQLITE_MISUSE, exception);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        Local<Value> argv[] = { exception };
        bool called = false;

        // Call all callbacks with the error object.
        while (!queue.empty()) {
            Call* call = queue.front();
<<<<<<< HEAD
            Local<Function> cb = Nan::New(call->baton->callback);
            if (!cb.IsEmpty() && cb->IsFunction()) {
                TRY_CATCH_CALL(this->handle(), cb, 1, argv);
=======
            Local<Function> cb = NanNew(call->baton->callback);
            if (!cb.IsEmpty() && cb->IsFunction()) {
                TRY_CATCH_CALL(NanObjectWrapHandle(this), cb, 1, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
                called = true;
            }
            queue.pop();
            // We don't call the actual callback, so we have to make sure that
            // the baton gets destroyed.
            delete call->baton;
            delete call;
        }

        // When we couldn't call a callback function, emit an error on the
        // Database object.
        if (!called) {
<<<<<<< HEAD
            Local<Value> info[] = { Nan::New("error").ToLocalChecked(), exception };
            EMIT_EVENT(handle(), 2, info);
=======
            Local<Value> args[] = { NanNew("error"), exception };
            EMIT_EVENT(NanObjectWrapHandle(this), 2, args);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        }
        return;
    }

    while (open && (!locked || pending == 0) && !queue.empty()) {
        Call* call = queue.front();

        if (call->exclusive && pending > 0) {
            break;
        }

        queue.pop();
        locked = call->exclusive;
        call->callback(call->baton);
        delete call;

        if (locked) break;
    }
}

void Database::Schedule(Work_Callback callback, Baton* baton, bool exclusive) {
<<<<<<< HEAD
    Nan::HandleScope scope;

    if (!open && locked) {
        EXCEPTION(Nan::New("Database is closed").ToLocalChecked(), SQLITE_MISUSE, exception);
        Local<Function> cb = Nan::New(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { exception };
            TRY_CATCH_CALL(handle(), cb, 1, argv);
        }
        else {
            Local<Value> argv[] = { Nan::New("error").ToLocalChecked(), exception };
            EMIT_EVENT(handle(), 2, argv);
=======
    NanScope();
    if (!open && locked) {
        EXCEPTION(NanNew<String>("Database is closed"), SQLITE_MISUSE, exception);
        Local<Function> cb = NanNew(baton->callback);
        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { exception };
            TRY_CATCH_CALL(NanObjectWrapHandle(this), cb, 1, argv);
        }
        else {
            Local<Value> argv[] = { NanNew("error"), exception };
            EMIT_EVENT(NanObjectWrapHandle(this), 2, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        }
        return;
    }

    if (!open || ((locked || exclusive || serialize) && pending > 0)) {
        queue.push(new Call(callback, baton, exclusive || serialize));
    }
    else {
        locked = exclusive;
        callback(baton);
    }
}

NAN_METHOD(Database::New) {
<<<<<<< HEAD
    if (!info.IsConstructCall()) {
        return Nan::ThrowTypeError("Use the new operator to create new Database objects");
=======
    NanScope();

    if (!args.IsConstructCall()) {
        return NanThrowTypeError("Use the new operator to create new Database objects");
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    }

    REQUIRE_ARGUMENT_STRING(0, filename);
    int pos = 1;

    int mode;
<<<<<<< HEAD
    if (info.Length() >= pos && info[pos]->IsInt32()) {
        mode = Nan::To<int>(info[pos++]).FromJust();
=======
    if (args.Length() >= pos && args[pos]->IsInt32()) {
        mode = args[pos++]->Int32Value();
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    } else {
        mode = SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE | SQLITE_OPEN_FULLMUTEX;
    }

    Local<Function> callback;
<<<<<<< HEAD
    if (info.Length() >= pos && info[pos]->IsFunction()) {
        callback = Local<Function>::Cast(info[pos++]);
    }

    Database* db = new Database();
    db->Wrap(info.This());

    info.This()->ForceSet(Nan::New("filename").ToLocalChecked(), info[0].As<String>(), ReadOnly);
    info.This()->ForceSet(Nan::New("mode").ToLocalChecked(), Nan::New(mode), ReadOnly);
=======
    if (args.Length() >= pos && args[pos]->IsFunction()) {
        callback = Local<Function>::Cast(args[pos++]);
    }

    Database* db = new Database();
    db->Wrap(args.This());

    args.This()->ForceSet(NanNew("filename"), args[0]->ToString(), ReadOnly);
    args.This()->ForceSet(NanNew("mode"), NanNew<Integer>(mode), ReadOnly);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    // Start opening the database.
    OpenBaton* baton = new OpenBaton(db, callback, *filename, mode);
    Work_BeginOpen(baton);

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
=======
    NanReturnValue(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
}

void Database::Work_BeginOpen(Baton* baton) {
    int status = uv_queue_work(uv_default_loop(),
        &baton->request, Work_Open, (uv_after_work_cb)Work_AfterOpen);
    assert(status == 0);
}

void Database::Work_Open(uv_work_t* req) {
    OpenBaton* baton = static_cast<OpenBaton*>(req->data);
    Database* db = baton->db;

    baton->status = sqlite3_open_v2(
        baton->filename.c_str(),
        &db->_handle,
        baton->mode,
        NULL
    );

    if (baton->status != SQLITE_OK) {
        baton->message = std::string(sqlite3_errmsg(db->_handle));
        sqlite3_close(db->_handle);
        db->_handle = NULL;
    }
    else {
        // Set default database handle values.
        sqlite3_busy_timeout(db->_handle, 1000);
    }
}

void Database::Work_AfterOpen(uv_work_t* req) {
<<<<<<< HEAD
    Nan::HandleScope scope;

=======
    NanScope();
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    OpenBaton* baton = static_cast<OpenBaton*>(req->data);
    Database* db = baton->db;

    Local<Value> argv[1];
    if (baton->status != SQLITE_OK) {
<<<<<<< HEAD
        EXCEPTION(Nan::New(baton->message.c_str()).ToLocalChecked(), baton->status, exception);
=======
        EXCEPTION(NanNew<String>(baton->message.c_str()), baton->status, exception);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        argv[0] = exception;
    }
    else {
        db->open = true;
<<<<<<< HEAD
        argv[0] = Nan::Null();
    }

    Local<Function> cb = Nan::New(baton->callback);

    if (!cb.IsEmpty() && cb->IsFunction()) {
        TRY_CATCH_CALL(db->handle(), cb, 1, argv);
    }
    else if (!db->open) {
        Local<Value> info[] = { Nan::New("error").ToLocalChecked(), argv[0] };
        EMIT_EVENT(db->handle(), 2, info);
    }

    if (db->open) {
        Local<Value> info[] = { Nan::New("open").ToLocalChecked() };
        EMIT_EVENT(db->handle(), 1, info);
=======
        argv[0] = NanNew(NanNull());
    }

    Local<Function> cb = NanNew(baton->callback);

    if (!cb.IsEmpty() && cb->IsFunction()) {
        TRY_CATCH_CALL(NanObjectWrapHandle(db), cb, 1, argv);
    }
    else if (!db->open) {
        Local<Value> args[] = { NanNew("error"), argv[0] };
        EMIT_EVENT(NanObjectWrapHandle(db), 2, args);
    }

    if (db->open) {
        Local<Value> args[] = { NanNew("open") };
        EMIT_EVENT(NanObjectWrapHandle(db), 1, args);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        db->Process();
    }

    delete baton;
}

NAN_GETTER(Database::OpenGetter) {
<<<<<<< HEAD
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
    info.GetReturnValue().Set(db->open);
}

NAN_METHOD(Database::Close) {
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
=======
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
    NanReturnValue(NanNew<Boolean>(db->open));
}

NAN_METHOD(Database::Close) {
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    Baton* baton = new Baton(db, callback);
    db->Schedule(Work_BeginClose, baton, true);

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
=======
    NanReturnValue(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
}

void Database::Work_BeginClose(Baton* baton) {
    assert(baton->db->locked);
    assert(baton->db->open);
    assert(baton->db->_handle);
    assert(baton->db->pending == 0);

    baton->db->RemoveCallbacks();
    int status = uv_queue_work(uv_default_loop(),
        &baton->request, Work_Close, (uv_after_work_cb)Work_AfterClose);
    assert(status == 0);
}

void Database::Work_Close(uv_work_t* req) {
    Baton* baton = static_cast<Baton*>(req->data);
    Database* db = baton->db;

    baton->status = sqlite3_close(db->_handle);

    if (baton->status != SQLITE_OK) {
        baton->message = std::string(sqlite3_errmsg(db->_handle));
    }
    else {
        db->_handle = NULL;
    }
}

void Database::Work_AfterClose(uv_work_t* req) {
<<<<<<< HEAD
    Nan::HandleScope scope;

=======
    NanScope();
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    Baton* baton = static_cast<Baton*>(req->data);
    Database* db = baton->db;

    Local<Value> argv[1];
    if (baton->status != SQLITE_OK) {
<<<<<<< HEAD
        EXCEPTION(Nan::New(baton->message.c_str()).ToLocalChecked(), baton->status, exception);
=======
        EXCEPTION(NanNew<String>(baton->message.c_str()), baton->status, exception);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        argv[0] = exception;
    }
    else {
        db->open = false;
        // Leave db->locked to indicate that this db object has reached
        // the end of its life.
<<<<<<< HEAD
        argv[0] = Nan::Null();
    }

    Local<Function> cb = Nan::New(baton->callback);

    // Fire callbacks.
    if (!cb.IsEmpty() && cb->IsFunction()) {
        TRY_CATCH_CALL(db->handle(), cb, 1, argv);
    }
    else if (db->open) {
        Local<Value> info[] = { Nan::New("error").ToLocalChecked(), argv[0] };
        EMIT_EVENT(db->handle(), 2, info);
    }

    if (!db->open) {
        Local<Value> info[] = { Nan::New("close").ToLocalChecked(), argv[0] };
        EMIT_EVENT(db->handle(), 1, info);
=======
        argv[0] = NanNew(NanNull());
    }

    Local<Function> cb = NanNew(baton->callback);

    // Fire callbacks.
    if (!cb.IsEmpty() && cb->IsFunction()) {
        TRY_CATCH_CALL(NanObjectWrapHandle(db), cb, 1, argv);
    }
    else if (db->open) {
        Local<Value> args[] = { NanNew("error"), argv[0] };
        EMIT_EVENT(NanObjectWrapHandle(db), 2, args);
    }

    if (!db->open) {
        Local<Value> args[] = { NanNew("close"), argv[0] };
        EMIT_EVENT(NanObjectWrapHandle(db), 1, args);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        db->Process();
    }

    delete baton;
}

NAN_METHOD(Database::Serialize) {
<<<<<<< HEAD
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
=======
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    bool before = db->serialize;
    db->serialize = true;

    if (!callback.IsEmpty() && callback->IsFunction()) {
<<<<<<< HEAD
        TRY_CATCH_CALL(info.This(), callback, 0, NULL);
=======
        TRY_CATCH_CALL(args.This(), callback, 0, NULL);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        db->serialize = before;
    }

    db->Process();

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
}

NAN_METHOD(Database::Parallelize) {
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
=======
    NanReturnValue(args.This());
}

NAN_METHOD(Database::Parallelize) {
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    bool before = db->serialize;
    db->serialize = false;

    if (!callback.IsEmpty() && callback->IsFunction()) {
<<<<<<< HEAD
        TRY_CATCH_CALL(info.This(), callback, 0, NULL);
=======
        TRY_CATCH_CALL(args.This(), callback, 0, NULL);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        db->serialize = before;
    }

    db->Process();

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
}

NAN_METHOD(Database::Configure) {
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());

    REQUIRE_ARGUMENTS(2);

    if (Nan::Equals(info[0], Nan::New("trace").ToLocalChecked()).FromJust()) {
=======
    NanReturnValue(args.This());
}

NAN_METHOD(Database::Configure) {
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());

    REQUIRE_ARGUMENTS(2);

    if (args[0]->Equals(NanNew("trace"))) {
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        Local<Function> handle;
        Baton* baton = new Baton(db, handle);
        db->Schedule(RegisterTraceCallback, baton);
    }
<<<<<<< HEAD
    else if (Nan::Equals(info[0], Nan::New("profile").ToLocalChecked()).FromJust()) {
=======
    else if (args[0]->Equals(NanNew("profile"))) {
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        Local<Function> handle;
        Baton* baton = new Baton(db, handle);
        db->Schedule(RegisterProfileCallback, baton);
    }
<<<<<<< HEAD
    else if (Nan::Equals(info[0], Nan::New("busyTimeout").ToLocalChecked()).FromJust()) {
        if (!info[1]->IsInt32()) {
            return Nan::ThrowTypeError("Value must be an integer");
        }
        Local<Function> handle;
        Baton* baton = new Baton(db, handle);
        baton->status = Nan::To<int>(info[1]).FromJust();
        db->Schedule(SetBusyTimeout, baton);
    }
    else {
        return Nan::ThrowError(Exception::Error(String::Concat(
            Nan::To<String>(info[0]).ToLocalChecked(),
            Nan::New(" is not a valid configuration option").ToLocalChecked()
=======
    else if (args[0]->Equals(NanNew("busyTimeout"))) {
        if (!args[1]->IsInt32()) {
            return NanThrowTypeError("Value must be an integer");
        }
        Local<Function> handle;
        Baton* baton = new Baton(db, handle);
        baton->status = args[1]->Int32Value();
        db->Schedule(SetBusyTimeout, baton);
    }
    else {
        return NanThrowError(Exception::Error(String::Concat(
            args[0]->ToString(),
            NanNew<String>(" is not a valid configuration option")
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
        )));
    }

    db->Process();

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
=======
    NanReturnValue(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
}

void Database::SetBusyTimeout(Baton* baton) {
    assert(baton->db->open);
    assert(baton->db->_handle);

    // Abuse the status field for passing the timeout.
    sqlite3_busy_timeout(baton->db->_handle, baton->status);

    delete baton;
}

void Database::RegisterTraceCallback(Baton* baton) {
    assert(baton->db->open);
    assert(baton->db->_handle);
    Database* db = baton->db;

    if (db->debug_trace == NULL) {
        // Add it.
        db->debug_trace = new AsyncTrace(db, TraceCallback);
        sqlite3_trace(db->_handle, TraceCallback, db);
    }
    else {
        // Remove it.
        sqlite3_trace(db->_handle, NULL, NULL);
        db->debug_trace->finish();
        db->debug_trace = NULL;
    }

    delete baton;
}

void Database::TraceCallback(void* db, const char* sql) {
    // Note: This function is called in the thread pool.
    // Note: Some queries, such as "EXPLAIN" queries, are not sent through this.
    static_cast<Database*>(db)->debug_trace->send(new std::string(sql));
}

void Database::TraceCallback(Database* db, std::string* sql) {
    // Note: This function is called in the main V8 thread.
<<<<<<< HEAD
    Nan::HandleScope scope;

    Local<Value> argv[] = {
        Nan::New("trace").ToLocalChecked(),
        Nan::New(sql->c_str()).ToLocalChecked()
    };
    EMIT_EVENT(db->handle(), 2, argv);
=======
    NanScope();
    Local<Value> argv[] = {
        NanNew("trace"),
        NanNew<String>(sql->c_str())
    };
    EMIT_EVENT(NanObjectWrapHandle(db), 2, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    delete sql;
}

void Database::RegisterProfileCallback(Baton* baton) {
    assert(baton->db->open);
    assert(baton->db->_handle);
    Database* db = baton->db;

    if (db->debug_profile == NULL) {
        // Add it.
        db->debug_profile = new AsyncProfile(db, ProfileCallback);
        sqlite3_profile(db->_handle, ProfileCallback, db);
    }
    else {
        // Remove it.
        sqlite3_profile(db->_handle, NULL, NULL);
        db->debug_profile->finish();
        db->debug_profile = NULL;
    }

    delete baton;
}

void Database::ProfileCallback(void* db, const char* sql, sqlite3_uint64 nsecs) {
    // Note: This function is called in the thread pool.
    // Note: Some queries, such as "EXPLAIN" queries, are not sent through this.
    ProfileInfo* info = new ProfileInfo();
    info->sql = std::string(sql);
    info->nsecs = nsecs;
    static_cast<Database*>(db)->debug_profile->send(info);
}

void Database::ProfileCallback(Database *db, ProfileInfo* info) {
<<<<<<< HEAD
    Nan::HandleScope scope;

    Local<Value> argv[] = {
        Nan::New("profile").ToLocalChecked(),
        Nan::New(info->sql.c_str()).ToLocalChecked(),
        Nan::New<Number>((double)info->nsecs / 1000000.0)
    };
    EMIT_EVENT(db->handle(), 3, argv);
=======
    NanScope();
    Local<Value> argv[] = {
        NanNew("profile"),
        NanNew<String>(info->sql.c_str()),
        NanNew<Number>((double)info->nsecs / 1000000.0)
    };
    EMIT_EVENT(NanObjectWrapHandle(db), 3, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    delete info;
}

void Database::RegisterUpdateCallback(Baton* baton) {
    assert(baton->db->open);
    assert(baton->db->_handle);
    Database* db = baton->db;

    if (db->update_event == NULL) {
        // Add it.
        db->update_event = new AsyncUpdate(db, UpdateCallback);
        sqlite3_update_hook(db->_handle, UpdateCallback, db);
    }
    else {
        // Remove it.
        sqlite3_update_hook(db->_handle, NULL, NULL);
        db->update_event->finish();
        db->update_event = NULL;
    }

    delete baton;
}

void Database::UpdateCallback(void* db, int type, const char* database,
        const char* table, sqlite3_int64 rowid) {
    // Note: This function is called in the thread pool.
    // Note: Some queries, such as "EXPLAIN" queries, are not sent through this.
    UpdateInfo* info = new UpdateInfo();
    info->type = type;
    info->database = std::string(database);
    info->table = std::string(table);
    info->rowid = rowid;
    static_cast<Database*>(db)->update_event->send(info);
}

void Database::UpdateCallback(Database *db, UpdateInfo* info) {
<<<<<<< HEAD
    Nan::HandleScope scope;

    Local<Value> argv[] = {
        Nan::New(sqlite_authorizer_string(info->type)).ToLocalChecked(),
        Nan::New(info->database.c_str()).ToLocalChecked(),
        Nan::New(info->table.c_str()).ToLocalChecked(),
        Nan::New<Number>(info->rowid),
    };
    EMIT_EVENT(db->handle(), 4, argv);
=======
    NanScope();

    Local<Value> argv[] = {
        NanNew(sqlite_authorizer_string(info->type)),
        NanNew<String>(info->database.c_str()),
        NanNew<String>(info->table.c_str()),
        NanNew<Number>(info->rowid),
    };
    EMIT_EVENT(NanObjectWrapHandle(db), 4, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    delete info;
}

NAN_METHOD(Database::Exec) {
<<<<<<< HEAD
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
=======
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    REQUIRE_ARGUMENT_STRING(0, sql);
    OPTIONAL_ARGUMENT_FUNCTION(1, callback);

    Baton* baton = new ExecBaton(db, callback, *sql);
    db->Schedule(Work_BeginExec, baton, true);

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
=======
    NanReturnValue(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
}

void Database::Work_BeginExec(Baton* baton) {
    assert(baton->db->locked);
    assert(baton->db->open);
    assert(baton->db->_handle);
    assert(baton->db->pending == 0);
    int status = uv_queue_work(uv_default_loop(),
        &baton->request, Work_Exec, (uv_after_work_cb)Work_AfterExec);
    assert(status == 0);
}

void Database::Work_Exec(uv_work_t* req) {
    ExecBaton* baton = static_cast<ExecBaton*>(req->data);

    char* message = NULL;
    baton->status = sqlite3_exec(
        baton->db->_handle,
        baton->sql.c_str(),
        NULL,
        NULL,
        &message
    );

    if (baton->status != SQLITE_OK && message != NULL) {
        baton->message = std::string(message);
        sqlite3_free(message);
    }
}

void Database::Work_AfterExec(uv_work_t* req) {
<<<<<<< HEAD
    Nan::HandleScope scope;

    ExecBaton* baton = static_cast<ExecBaton*>(req->data);
    Database* db = baton->db;

    Local<Function> cb = Nan::New(baton->callback);

    if (baton->status != SQLITE_OK) {
        EXCEPTION(Nan::New(baton->message.c_str()).ToLocalChecked(), baton->status, exception);

        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { exception };
            TRY_CATCH_CALL(db->handle(), cb, 1, argv);
        }
        else {
            Local<Value> info[] = { Nan::New("error").ToLocalChecked(), exception };
            EMIT_EVENT(db->handle(), 2, info);
        }
    }
    else if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { Nan::Null() };
        TRY_CATCH_CALL(db->handle(), cb, 1, argv);
=======
    NanScope();
    ExecBaton* baton = static_cast<ExecBaton*>(req->data);
    Database* db = baton->db;

    Local<Function> cb = NanNew(baton->callback);

    if (baton->status != SQLITE_OK) {
        EXCEPTION(NanNew<String>(baton->message.c_str()), baton->status, exception);

        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { exception };
            TRY_CATCH_CALL(NanObjectWrapHandle(db), cb, 1, argv);
        }
        else {
            Local<Value> args[] = { NanNew("error"), exception };
            EMIT_EVENT(NanObjectWrapHandle(db), 2, args);
        }
    }
    else if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { NanNew(NanNull()) };
        TRY_CATCH_CALL(NanObjectWrapHandle(db), cb, 1, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    }

    db->Process();

    delete baton;
}

NAN_METHOD(Database::Wait) {
<<<<<<< HEAD
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
=======
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    OPTIONAL_ARGUMENT_FUNCTION(0, callback);

    Baton* baton = new Baton(db, callback);
    db->Schedule(Work_Wait, baton, true);

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
}

void Database::Work_Wait(Baton* baton) {
    Nan::HandleScope scope;
=======
    NanReturnValue(args.This());
}

void Database::Work_Wait(Baton* baton) {
    NanScope();
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    assert(baton->db->locked);
    assert(baton->db->open);
    assert(baton->db->_handle);
    assert(baton->db->pending == 0);

<<<<<<< HEAD
    Local<Function> cb = Nan::New(baton->callback);
    if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { Nan::Null() };
        TRY_CATCH_CALL(baton->db->handle(), cb, 1, argv);
=======
    Local<Function> cb = NanNew(baton->callback);
    if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { NanNew(NanNull()) };
        TRY_CATCH_CALL(NanObjectWrapHandle(baton->db), cb, 1, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    }

    baton->db->Process();

    delete baton;
}

NAN_METHOD(Database::LoadExtension) {
<<<<<<< HEAD
    Database* db = Nan::ObjectWrap::Unwrap<Database>(info.This());
=======
    NanScope();
    Database* db = ObjectWrap::Unwrap<Database>(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    REQUIRE_ARGUMENT_STRING(0, filename);
    OPTIONAL_ARGUMENT_FUNCTION(1, callback);

    Baton* baton = new LoadExtensionBaton(db, callback, *filename);
    db->Schedule(Work_BeginLoadExtension, baton, true);

<<<<<<< HEAD
    info.GetReturnValue().Set(info.This());
=======
    NanReturnValue(args.This());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
}

void Database::Work_BeginLoadExtension(Baton* baton) {
    assert(baton->db->locked);
    assert(baton->db->open);
    assert(baton->db->_handle);
    assert(baton->db->pending == 0);
    int status = uv_queue_work(uv_default_loop(),
<<<<<<< HEAD
        &baton->request, Work_LoadExtension, reinterpret_cast<uv_after_work_cb>(Work_AfterLoadExtension));
=======
        &baton->request, Work_LoadExtension, (uv_after_work_cb)Work_AfterLoadExtension);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    assert(status == 0);
}

void Database::Work_LoadExtension(uv_work_t* req) {
    LoadExtensionBaton* baton = static_cast<LoadExtensionBaton*>(req->data);

    sqlite3_enable_load_extension(baton->db->_handle, 1);

    char* message = NULL;
    baton->status = sqlite3_load_extension(
        baton->db->_handle,
        baton->filename.c_str(),
        0,
        &message
    );

    sqlite3_enable_load_extension(baton->db->_handle, 0);

    if (baton->status != SQLITE_OK && message != NULL) {
        baton->message = std::string(message);
        sqlite3_free(message);
    }
}

void Database::Work_AfterLoadExtension(uv_work_t* req) {
<<<<<<< HEAD
    Nan::HandleScope scope;

    LoadExtensionBaton* baton = static_cast<LoadExtensionBaton*>(req->data);
    Database* db = baton->db;
    Local<Function> cb = Nan::New(baton->callback);

    if (baton->status != SQLITE_OK) {
        EXCEPTION(Nan::New(baton->message.c_str()).ToLocalChecked(), baton->status, exception);

        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { exception };
            TRY_CATCH_CALL(db->handle(), cb, 1, argv);
        }
        else {
            Local<Value> info[] = { Nan::New("error").ToLocalChecked(), exception };
            EMIT_EVENT(db->handle(), 2, info);
        }
    }
    else if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { Nan::Null() };
        TRY_CATCH_CALL(db->handle(), cb, 1, argv);
=======
    NanScope();
    LoadExtensionBaton* baton = static_cast<LoadExtensionBaton*>(req->data);
    Database* db = baton->db;
    Local<Function> cb = NanNew(baton->callback);

    if (baton->status != SQLITE_OK) {
        EXCEPTION(NanNew<String>(baton->message.c_str()), baton->status, exception);

        if (!cb.IsEmpty() && cb->IsFunction()) {
            Local<Value> argv[] = { exception };
            TRY_CATCH_CALL(NanObjectWrapHandle(db), cb, 1, argv);
        }
        else {
            Local<Value> args[] = { NanNew("error"), exception };
            EMIT_EVENT(NanObjectWrapHandle(db), 2, args);
        }
    }
    else if (!cb.IsEmpty() && cb->IsFunction()) {
        Local<Value> argv[] = { NanNew(NanNull()) };
        TRY_CATCH_CALL(NanObjectWrapHandle(db), cb, 1, argv);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    }

    db->Process();

    delete baton;
}

void Database::RemoveCallbacks() {
    if (debug_trace) {
        debug_trace->finish();
        debug_trace = NULL;
    }
    if (debug_profile) {
        debug_profile->finish();
        debug_profile = NULL;
    }
}
