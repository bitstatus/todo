module.exports = MultiPoint;

var util = require('util');

var Types = require('./types');
var Geometry = require('./geometry');
<<<<<<< HEAD
var Point = require('./point');
var BinaryWriter = require('./binarywriter');
var ZigZag = require('./zigzag');

function MultiPoint(points) {
    Geometry.call(this);

=======
var BinaryWriter = require('./binarywriter');

function MultiPoint(points) {
    Geometry.call(this);
    
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    this.points = points || [];
}

util.inherits(MultiPoint, Geometry);

<<<<<<< HEAD
MultiPoint.Z = function (points) {
    var multiPoint = new MultiPoint(points);
    multiPoint.hasZ = true;
    return multiPoint;
};

MultiPoint.M = function (points) {
    var multiPoint = new MultiPoint(points);
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint.ZM = function (points) {
    var multiPoint = new MultiPoint(points);
    multiPoint.hasZ = true;
    multiPoint.hasM = true;
    return multiPoint;
};

MultiPoint._parseWkt = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;
=======
MultiPoint._parseWkt = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    if (value.isMatch(['EMPTY']))
        return multiPoint;

    value.expectGroupStart();
<<<<<<< HEAD
    multiPoint.points.push.apply(multiPoint.points, value.matchCoordinates(options));
=======
    multiPoint.points.push.apply(multiPoint.points, value.matchCoordinates());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
    value.expectGroupEnd();

    return multiPoint;
};

MultiPoint._parseWkb = function (value, options) {
<<<<<<< HEAD
    var multiPoint = new MultiPoint();
    multiPoint.srid = options.srid;
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;
=======
    var multiPoint = new MultiPoint(); 
    multiPoint.srid = options.srid;
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    var pointCount = value.readUInt32();

    for (var i = 0; i < pointCount; i++)
<<<<<<< HEAD
        multiPoint.points.push(Geometry.parse(value, options));

    return multiPoint;
};

MultiPoint._parseTwkb = function (value, options) {
    var multiPoint = new MultiPoint();
    multiPoint.hasZ = options.hasZ;
    multiPoint.hasM = options.hasM;

    if (options.isEmpty)
        return multiPoint;

    var previousPoint = new Point(0, 0, options.hasZ ? 0 : undefined, options.hasM ? 0 : undefined);
    var pointCount = value.readVarInt();

    for (var i = 0; i < pointCount; i++)
        multiPoint.points.push(Point._readTwkbPoint(value, options, previousPoint));

    return multiPoint;
};

MultiPoint._parseGeoJSON = function (value) {
    var multiPoint = new MultiPoint();

    if (value.coordinates.length > 0)
        multiPoint.hasZ = value.coordinates[0].length > 2;

    for (var i = 0; i < value.coordinates.length; i++)
        multiPoint.points.push(Point._parseGeoJSON({ coordinates: value.coordinates[i] }));
=======
        multiPoint.points.push(Geometry.parse(value));
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    return multiPoint;
};

MultiPoint.prototype.toWkt = function () {
    if (this.points.length === 0)
<<<<<<< HEAD
        return this._getWktType(Types.wkt.MultiPoint, true);

    var wkt = this._getWktType(Types.wkt.MultiPoint, false) + '(';

    for (var i = 0; i < this.points.length; i++)
        wkt += this._getWktCoordinate(this.points[i]) + ',';
=======
        return Types.wkt.MultiPoint + ' EMPTY';

    var wkt = Types.wkt.MultiPoint + '(';

    for (var i = 0; i < this.points.length; i++)
        wkt += this.points[i].x + ' ' + this.points[i].y + ',';
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    wkt = wkt.slice(0, -1);
    wkt += ')';

    return wkt;
};

MultiPoint.prototype.toWkb = function () {
    var wkb = new BinaryWriter(this._getWkbSize());

    wkb.writeInt8(1);

<<<<<<< HEAD
    this._writeWkbType(wkb, Types.wkb.MultiPoint);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        wkb.writeBuffer(this.points[i].toWkb({ srid: this.srid }));
=======
    wkb.writeUInt32LE(Types.wkb.MultiPoint);
    wkb.writeUInt32LE(this.points.length);

    for (var i = 0; i < this.points.length; i++)
        wkb.writeBuffer(this.points[i].toWkb());
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722

    return wkb.buffer;
};

<<<<<<< HEAD
MultiPoint.prototype.toTwkb = function () {
    var twkb = new BinaryWriter(0, true);

    var precision = Geometry.getTwkbPrecision(5, 0, 0);
    var isEmpty = this.points.length === 0;

    this._writeTwkbHeader(twkb, Types.wkb.MultiPoint, precision, isEmpty);

    if (this.points.length > 0) {
        twkb.writeVarInt(this.points.length);

        var previousPoint = new Point(0, 0, 0, 0);
        for (var i = 0; i < this.points.length; i++)
            this.points[i]._writeTwkbPoint(twkb, precision, previousPoint);
    }

    return twkb.buffer;
};

MultiPoint.prototype._getWkbSize = function () {
    var coordinateSize = 16;

    if (this.hasZ)
        coordinateSize += 8;
    if (this.hasM)
        coordinateSize += 8;

    coordinateSize += 5;

    return 1 + 4 + 4 + (this.points.length * coordinateSize);
};

MultiPoint.prototype.toGeoJSON = function (options) {
    var geoJSON = Geometry.prototype.toGeoJSON.call(this, options);
    geoJSON.type = Types.geoJSON.MultiPoint;
    geoJSON.coordinates = [];

    for (var i = 0; i < this.points.length; i++)
        geoJSON.coordinates.push(this.points[i].toGeoJSON().coordinates);

    return geoJSON;
=======
MultiPoint.prototype._getWkbSize = function () {
    return 1 + 4 + 4 + (this.points.length * 21);
>>>>>>> e38eb0b10e6a05a1b0f1ab681516ea4290ca9722
};
